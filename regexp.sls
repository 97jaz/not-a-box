(library (regexp)
  (export (rename (1/byte-regexp byte-regexp)
                  (1/byte-regexp? byte-regexp?)
                  (1/regexp regexp)
                  (1/regexp-match-peek-positions-immediate/end regexp-match-peek-positions-immediate/end)
                  (1/regexp-match-peek-positions-immediate regexp-match-peek-positions-immediate)
                  (1/regexp-match-peek-positions regexp-match-peek-positions)
                  (1/regexp-max-lookbehind regexp-max-lookbehind)
                  (1/regexp-match/end regexp-match/end)
                  (1/regexp-match-peek regexp-match-peek)
                  (1/regexp-replace* regexp-replace*)
                  (1/pregexp pregexp)
                  (1/regexp-match-positions/end regexp-match-positions/end)
                  (1/regexp-match-peek-immediate regexp-match-peek-immediate)
                  (1/regexp-match? regexp-match?)
                  (1/regexp-match-positions regexp-match-positions)
                  (1/regexp-replace regexp-replace)
                  (1/pregexp? pregexp?)
                  (1/regexp-match-peek-positions/end regexp-match-peek-positions/end)
                  (1/regexp? regexp?)
                  (1/regexp-match regexp-match)
                  (1/byte-pregexp byte-pregexp)
                  (1/byte-pregexp? byte-pregexp?)))
  (import (except (chezscheme)
                  read-char
                  close-input-port close-output-port
                  make-input-port make-output-port
                  open-input-file peek-char
                  error)
          (hash)
          (struct)
          (port)
          (bytes)
          (error))
  (define-syntax begin0
    (syntax-rules ()
      [(_ expr0 expr ...)
       (let ([l (call-with-values (lambda () expr0) list)])
         expr ...
         (apply values l))]))
  (define null '())
  (define eof #!eof)
  (define (exact-integer? n) (and (integer? n) (exact? n)))
  (define (exact-nonnegative-integer? n) (and (exact-integer? n) (>= n 0)))
  (define (exact-positive-integer? n) (and (exact-integer? n) (> n 0)))
  (define (byte? n) (and (exact-integer? n) (>= n 0) (<= n 255)))
  (define (procedure-arity-includes? p n) #t)
  (define (vector->immutable-vector x) x)
  (define (string->immutable-string x) x)
  (define (make-continuation-prompt-tag s) (gensym))
  (define (call-with-continuation-prompt proc . args) (proc))
  (define (abort-current-continuation . args)
    (error 'abort-current-continuation "fixme"))
  (define unsafe-car car)
  (define unsafe-cdr cdr)
  (define unsafe-fx< fx<)
  (define unsafe-fx+ fx+)
  (define (current-inspector) #f)
  (define (char-graphic? x) #f)
  (define unsafe-vector-length vector-length)
  (define unsafe-vector-ref vector-ref)
  (define unsafe-bytes-length bytes-length)
  (define unsafe-bytes-ref bytes-ref)
  (define arithmetic-shift bitwise-arithmetic-shift)
  (define vector-copy!
    (case-lambda
     [(dest d-start src) (vector-copy! dest d-start src 0 (vector-length src))]
     [(dest d-start src s-start) (vector-copy! dest d-start src s-start (vector-length src))]
     [(dest d-start src s-start s-end)
      (let loop ([i (- s-end s-start)])
        (unless (zero? i)
          (let ([i (sub1 i)])
            (vector-set! dest (+ d-start i) (vector-ref src (+ s-start i)))
            (loop i))))]))
  (define-values (prop:custom-write custom-write? custom-write-ref)
    (make-struct-type-property 'custom-write))
  (include "regexp.scm"))
